2024-07-03 23:30:47,427 - DEBUG - load_ssl_context verify=True cert=None trust_env=True http2=False
2024-07-03 23:30:47,433 - DEBUG - load_verify_locations cafile='/home/isaac/myamble/myamble-pwa-3.0.jv.0/generate/4/venv/lib/python3.12/site-packages/certifi/cacert.pem'
2024-07-03 23:30:47,450 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: System Architecture Design\n\nRequirements: Design a comprehensive system architecture for the Social Work Survey Application. Include microservices, databases, API gateway, and integration points.\n\nDependencies: '}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:30:47,667 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:30:47,670 - DEBUG - connect_tcp.started host='api.anthropic.com' port=443 local_address=None timeout=600 socket_options=None
2024-07-03 23:30:47,711 - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7a624bc1e030>
2024-07-03 23:30:47,714 - DEBUG - start_tls.started ssl_context=<ssl.SSLContext object at 0x7a624b5e5150> server_hostname='api.anthropic.com' timeout=600
2024-07-03 23:30:47,761 - DEBUG - start_tls.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7a624b4a1130>
2024-07-03 23:30:47,763 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:30:47,766 - DEBUG - send_request_headers.complete
2024-07-03 23:30:47,768 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:30:47,770 - DEBUG - send_request_body.complete
2024-07-03 23:30:47,771 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:30:54,145 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:30:54 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_01UNbS56h7X8BzucQEe6YtbE'), (b'x-cloud-trace-context', b'e14d62a36b7c8c27cb3eb8342cf7c656'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc61ccaf484684-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:30:54,151 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:30:54,153 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:30:54,156 - DEBUG - receive_response_body.complete
2024-07-03 23:30:54,158 - DEBUG - response_closed.started
2024-07-03 23:30:54,160 - DEBUG - response_closed.complete
2024-07-03 23:30:54,162 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:30:54 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_01UNbS56h7X8BzucQEe6YtbE', 'x-cloud-trace-context': 'e14d62a36b7c8c27cb3eb8342cf7c656', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc61ccaf484684-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:30:54,175 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: PostgreSQL Database Schema: Users and Authentication\n\nRequirements: Design the database schema for user management and authentication, including tables for users, roles, and permissions.\n\nDependencies: System Architecture Design: [TextBlock(text=\'```typescript\\n// System Architecture Design\\n\\n// Requirements:\\n// Design a comprehensive system architecture for the Social Work Survey Application. The architecture should follow a microservices approach and include the following components:\\n// - Frontend Single Page Application (SPA)\\n// - API Gateway\\n// - User Service (for authentication and user management)\\n// - Survey Service (for creating, managing, and responding to surveys)\\n// - Analytics Service (for AI-powered data analysis and visualization)\\n\', type=\'text\')]'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:30:54,373 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:30:54,375 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:30:54,378 - DEBUG - send_request_headers.complete
2024-07-03 23:30:54,380 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:30:54,382 - DEBUG - send_request_body.complete
2024-07-03 23:30:54,384 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:31:00,714 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:31:00 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_018XsaEayo3x56gn4jrJTd1y'), (b'x-cloud-trace-context', b'0939d396f29acff61ded414762926f65'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc61f5fca04684-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:31:00,723 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:31:00,725 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:31:00,727 - DEBUG - receive_response_body.complete
2024-07-03 23:31:00,728 - DEBUG - response_closed.started
2024-07-03 23:31:00,730 - DEBUG - response_closed.complete
2024-07-03 23:31:00,732 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:31:00 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_018XsaEayo3x56gn4jrJTd1y', 'x-cloud-trace-context': '0939d396f29acff61ded414762926f65', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc61f5fca04684-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:31:00,739 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: PostgreSQL Database Schema: Surveys and Questions\n\nRequirements: Create the database schema for surveys and questions, including support for different question types and branching logic.\n\nDependencies: System Architecture Design: [TextBlock(text=\'```typescript\\n// System Architecture Design\\n\\n// Requirements:\\n// Design a comprehensive system architecture for the Social Work Survey Application. The architecture should follow a microservices approach and include the following components:\\n// - Frontend Single Page Application (SPA)\\n// - API Gateway\\n// - User Service (for authentication and user management)\\n// - Survey Service (for creating, managing, and responding to surveys)\\n// - Analytics Service (for AI-powered data analysis and visualization)\\n\', type=\'text\')]'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:31:00,967 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:31:00,969 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:31:00,972 - DEBUG - send_request_headers.complete
2024-07-03 23:31:00,974 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:31:00,976 - DEBUG - send_request_body.complete
2024-07-03 23:31:00,978 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:31:07,311 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:31:07 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_01Lfj3qqSwihCqS98D6R3Nyq'), (b'x-cloud-trace-context', b'a932b2ea9ed6f42282aaf36b95e9ce82'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc621f2be54684-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:31:07,315 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:31:07,317 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:31:07,318 - DEBUG - receive_response_body.complete
2024-07-03 23:31:07,320 - DEBUG - response_closed.started
2024-07-03 23:31:07,322 - DEBUG - response_closed.complete
2024-07-03 23:31:07,323 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:31:07 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_01Lfj3qqSwihCqS98D6R3Nyq', 'x-cloud-trace-context': 'a932b2ea9ed6f42282aaf36b95e9ce82', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc621f2be54684-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:31:07,331 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: PostgreSQL Database Schema: Responses and Analytics\n\nRequirements: Design the schema for storing survey responses and analytics data, optimized for quick retrieval and analysis.\n\nDependencies: System Architecture Design: [TextBlock(text=\'```typescript\\n// System Architecture Design\\n\\n// Requirements:\\n// Design a comprehensive system architecture for the Social Work Survey Application. The architecture should follow a microservices approach and include the following components:\\n// - Frontend Single Page Application (SPA)\\n// - API Gateway\\n// - User Service (for authentication and user management)\\n// - Survey Service (for creating, managing, and responding to surveys)\\n// - Analytics Service (for AI-powered data analysis and visualization)\\n\', type=\'text\')]'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:31:07,532 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:31:07,534 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:31:07,536 - DEBUG - send_request_headers.complete
2024-07-03 23:31:07,538 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:31:07,540 - DEBUG - send_request_body.complete
2024-07-03 23:31:07,542 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:31:13,838 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:31:13 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_01GKT6EPsrv3yRNM4dWBzJsf'), (b'x-cloud-trace-context', b'e485320043bdf6a52d301c1d508c5652'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc62484b644684-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:31:13,843 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:31:13,844 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:31:13,846 - DEBUG - receive_response_body.complete
2024-07-03 23:31:13,848 - DEBUG - response_closed.started
2024-07-03 23:31:13,850 - DEBUG - response_closed.complete
2024-07-03 23:31:13,852 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:31:13 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_01GKT6EPsrv3yRNM4dWBzJsf', 'x-cloud-trace-context': 'e485320043bdf6a52d301c1d508c5652', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc62484b644684-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:31:13,860 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: ClickHouse Database Schema: Analytics Data\n\nRequirements: Create the ClickHouse schema for storing and querying large-scale analytics data efficiently.\n\nDependencies: System Architecture Design: [TextBlock(text=\'```typescript\\n// System Architecture Design\\n\\n// Requirements:\\n// Design a comprehensive system architecture for the Social Work Survey Application. The architecture should follow a microservices approach and include the following components:\\n// - Frontend Single Page Application (SPA)\\n// - API Gateway\\n// - User Service (for authentication and user management)\\n// - Survey Service (for creating, managing, and responding to surveys)\\n// - Analytics Service (for AI-powered data analysis and visualization)\\n\', type=\'text\')]'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:31:14,079 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:31:14,081 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:31:14,083 - DEBUG - send_request_headers.complete
2024-07-03 23:31:14,085 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:31:14,087 - DEBUG - send_request_body.complete
2024-07-03 23:31:14,089 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:31:20,579 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:31:20 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_01XmUmW5imqiue8qPMSQRQDH'), (b'x-cloud-trace-context', b'62a9eefa3640d01c5a2311c7ed7eb157'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc62711bef4684-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:31:20,583 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:31:20,585 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:31:20,586 - DEBUG - receive_response_body.complete
2024-07-03 23:31:20,588 - DEBUG - response_closed.started
2024-07-03 23:31:20,590 - DEBUG - response_closed.complete
2024-07-03 23:31:20,591 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:31:20 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_01XmUmW5imqiue8qPMSQRQDH', 'x-cloud-trace-context': '62a9eefa3640d01c5a2311c7ed7eb157', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc62711bef4684-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:31:20,599 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: ClickHouse Database Schema: User Activity Logs\n\nRequirements: Design the schema for storing user activity logs in ClickHouse for performance analysis and auditing.\n\nDependencies: System Architecture Design: [TextBlock(text=\'```typescript\\n// System Architecture Design\\n\\n// Requirements:\\n// Design a comprehensive system architecture for the Social Work Survey Application. The architecture should follow a microservices approach and include the following components:\\n// - Frontend Single Page Application (SPA)\\n// - API Gateway\\n// - User Service (for authentication and user management)\\n// - Survey Service (for creating, managing, and responding to surveys)\\n// - Analytics Service (for AI-powered data analysis and visualization)\\n\', type=\'text\')]'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:31:20,812 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:31:20,822 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:31:20,827 - DEBUG - send_request_headers.complete
2024-07-03 23:31:20,837 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:31:20,839 - DEBUG - send_request_body.complete
2024-07-03 23:31:20,841 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:31:27,133 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:31:27 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_01DPb5cnsavyGr6TfkGsAGUS'), (b'x-cloud-trace-context', b'4ba7785fff9bb112c14fe743700c6409'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc629b4b6a4684-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:31:27,138 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:31:27,140 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:31:27,142 - DEBUG - receive_response_body.complete
2024-07-03 23:31:27,144 - DEBUG - response_closed.started
2024-07-03 23:31:27,146 - DEBUG - response_closed.complete
2024-07-03 23:31:27,147 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:31:27 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_01DPb5cnsavyGr6TfkGsAGUS', 'x-cloud-trace-context': '4ba7785fff9bb112c14fe743700c6409', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc629b4b6a4684-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:31:27,155 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: MongoDB Database Schema: Messages and Notifications\n\nRequirements: Create the MongoDB schema for storing messages and notifications, optimized for real-time operations.\n\nDependencies: System Architecture Design: [TextBlock(text=\'```typescript\\n// System Architecture Design\\n\\n// Requirements:\\n// Design a comprehensive system architecture for the Social Work Survey Application. The architecture should follow a microservices approach and include the following components:\\n// - Frontend Single Page Application (SPA)\\n// - API Gateway\\n// - User Service (for authentication and user management)\\n// - Survey Service (for creating, managing, and responding to surveys)\\n// - Analytics Service (for AI-powered data analysis and visualization)\\n\', type=\'text\')]'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:31:27,376 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:31:27,378 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:31:27,380 - DEBUG - send_request_headers.complete
2024-07-03 23:31:27,382 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:31:27,384 - DEBUG - send_request_body.complete
2024-07-03 23:31:27,386 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:31:33,686 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:31:33 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_012QbKCa97SoNUMReVYW7B4M'), (b'x-cloud-trace-context', b'88e0f95eddff05a18dfb6c8f9b46495a'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc62c43d374684-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:31:33,691 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:31:33,693 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:31:33,696 - DEBUG - receive_response_body.complete
2024-07-03 23:31:33,705 - DEBUG - response_closed.started
2024-07-03 23:31:33,707 - DEBUG - response_closed.complete
2024-07-03 23:31:33,709 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:31:33 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_012QbKCa97SoNUMReVYW7B4M', 'x-cloud-trace-context': '88e0f95eddff05a18dfb6c8f9b46495a', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc62c43d374684-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:31:33,721 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: MongoDB Database Schema: Survey Templates\n\nRequirements: Design the schema for storing reusable survey templates in MongoDB.\n\nDependencies: System Architecture Design: [TextBlock(text=\'```typescript\\n// System Architecture Design\\n\\n// Requirements:\\n// Design a comprehensive system architecture for the Social Work Survey Application. The architecture should follow a microservices approach and include the following components:\\n// - Frontend Single Page Application (SPA)\\n// - API Gateway\\n// - User Service (for authentication and user management)\\n// - Survey Service (for creating, managing, and responding to surveys)\\n// - Analytics Service (for AI-powered data analysis and visualization)\\n\', type=\'text\')]'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:31:33,929 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:31:33,931 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:31:33,933 - DEBUG - send_request_headers.complete
2024-07-03 23:31:33,935 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:31:33,938 - DEBUG - send_request_body.complete
2024-07-03 23:31:33,939 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:31:40,444 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:31:40 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_01MhGUwnSQhVYtRfvahZ4Hna'), (b'x-cloud-trace-context', b'caf67ea45db211d1ac0a8a1996ac70bf'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc62ed3f3e4684-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:31:40,449 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:31:40,451 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:31:40,453 - DEBUG - receive_response_body.complete
2024-07-03 23:31:40,455 - DEBUG - response_closed.started
2024-07-03 23:31:40,457 - DEBUG - response_closed.complete
2024-07-03 23:31:40,458 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:31:40 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_01MhGUwnSQhVYtRfvahZ4Hna', 'x-cloud-trace-context': 'caf67ea45db211d1ac0a8a1996ac70bf', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc62ed3f3e4684-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:31:40,466 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: API Design: User Management Endpoints\n\nRequirements: Design RESTful API endpoints for user registration, authentication, and profile management.\n\nDependencies: PostgreSQL Database Schema: Users and Authentication: [TextBlock(text=\'```sql\\n-- Users Table\\nCREATE TABLE users (\\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\\n    email VARCHAR(255) UNIQUE NOT NULL,\\n    password_hash VARCHAR(255) NOT NULL,\\n    role_id UUID NOT NULL REFERENCES roles(id),\\n    is_active BOOLEAN DEFAULT true,\\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\\n    updated_at TIMESTAMP WITH TIME\', type=\'text\')]'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:31:40,685 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:31:40,687 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:31:40,689 - DEBUG - send_request_headers.complete
2024-07-03 23:31:40,691 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:31:40,693 - DEBUG - send_request_body.complete
2024-07-03 23:31:40,695 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:31:43,882 - DEBUG - receive_response_headers.failed exception=KeyboardInterrupt()
2024-07-03 23:31:43,884 - DEBUG - response_closed.started
2024-07-03 23:31:43,886 - DEBUG - response_closed.complete
2024-07-03 23:45:12,637 - DEBUG - load_ssl_context verify=True cert=None trust_env=True http2=False
2024-07-03 23:45:12,643 - DEBUG - load_verify_locations cafile='/home/isaac/myamble/myamble-pwa-3.0.jv.0/generate/4/venv/lib/python3.12/site-packages/certifi/cacert.pem'
2024-07-03 23:45:12,660 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: System Architecture Design\n\nRequirements: Design a comprehensive system architecture for the Social Work Survey Application. Include microservices, databases, API gateway, and integration points.\n\nDependencies: '}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:45:12,896 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:45:12,898 - DEBUG - connect_tcp.started host='api.anthropic.com' port=443 local_address=None timeout=600 socket_options=None
2024-07-03 23:45:13,000 - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x74d484214e00>
2024-07-03 23:45:13,003 - DEBUG - start_tls.started ssl_context=<ssl.SSLContext object at 0x74d484351150> server_hostname='api.anthropic.com' timeout=600
2024-07-03 23:45:13,044 - DEBUG - start_tls.complete return_value=<httpcore._backends.sync.SyncStream object at 0x74d484b320c0>
2024-07-03 23:45:13,046 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:45:13,048 - DEBUG - send_request_headers.complete
2024-07-03 23:45:13,050 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:45:13,052 - DEBUG - send_request_body.complete
2024-07-03 23:45:13,054 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:45:19,310 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:45:19 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_01JxtKRGBYPWYgtxyTMD1FRf'), (b'x-cloud-trace-context', b'921cc4f978f3608a647a4eace94cd835'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc76ecada63165-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:45:19,316 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:45:19,319 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:45:19,322 - DEBUG - receive_response_body.complete
2024-07-03 23:45:19,325 - DEBUG - response_closed.started
2024-07-03 23:45:19,327 - DEBUG - response_closed.complete
2024-07-03 23:45:19,330 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:45:19 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_01JxtKRGBYPWYgtxyTMD1FRf', 'x-cloud-trace-context': '921cc4f978f3608a647a4eace94cd835', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc76ecada63165-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:45:19,344 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: PostgreSQL Database Schema: Users and Authentication\n\nRequirements: Design the database schema for user management and authentication, including tables for users, roles, and permissions.\n\nDependencies: System Architecture Design: [\'```typescript\\n// System Architecture Design\\n\\n// Requirements:\\n// Design a comprehensive system architecture for the Social Work Survey Application. The architecture should follow a microservices approach and include the following components:\\n// - Frontend Single Page Application (SPA)\\n// - API Gateway\\n// - User Service (for authentication and user management)\\n// - Survey Service (for creating, managing, and responding to surveys)\\n// - Analytics Service (for AI-powered data analysis and visualization)\\n\']'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:45:19,566 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:45:19,569 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:45:19,571 - DEBUG - send_request_headers.complete
2024-07-03 23:45:19,572 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:45:19,575 - DEBUG - send_request_body.complete
2024-07-03 23:45:19,576 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:45:25,876 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 200, b'OK', [(b'Date', b'Thu, 04 Jul 2024 04:45:25 GMT'), (b'Content-Type', b'application/json'), (b'Transfer-Encoding', b'chunked'), (b'Connection', b'keep-alive'), (b'request-id', b'req_01Cds68L5sPNcz3TAEiTCQiv'), (b'x-cloud-trace-context', b'94028cd20ef8e3e1ae97cd06e048d6ed'), (b'via', b'1.1 google'), (b'CF-Cache-Status', b'DYNAMIC'), (b'Server', b'cloudflare'), (b'CF-RAY', b'89dc77157b7e3165-DFW'), (b'Content-Encoding', b'gzip')])
2024-07-03 23:45:25,880 - INFO - HTTP Request: POST https://api.anthropic.com/v1/messages "HTTP/1.1 200 OK"
2024-07-03 23:45:25,882 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2024-07-03 23:45:25,884 - DEBUG - receive_response_body.complete
2024-07-03 23:45:25,886 - DEBUG - response_closed.started
2024-07-03 23:45:25,887 - DEBUG - response_closed.complete
2024-07-03 23:45:25,889 - DEBUG - HTTP Response: POST https://api.anthropic.com/v1/messages "200 OK" Headers({'date': 'Thu, 04 Jul 2024 04:45:25 GMT', 'content-type': 'application/json', 'transfer-encoding': 'chunked', 'connection': 'keep-alive', 'request-id': 'req_01Cds68L5sPNcz3TAEiTCQiv', 'x-cloud-trace-context': '94028cd20ef8e3e1ae97cd06e048d6ed', 'via': '1.1 google', 'cf-cache-status': 'DYNAMIC', 'server': 'cloudflare', 'cf-ray': '89dc77157b7e3165-DFW', 'content-encoding': 'gzip'})
2024-07-03 23:45:25,897 - DEBUG - Request options: {'method': 'post', 'url': '/v1/messages', 'timeout': 600, 'files': None, 'json_data': {'max_tokens': 100, 'messages': [{'role': 'user', 'content': '<context>You\'re absolutely right. I\'ll create a more technical and comprehensive specification that dives deeper into the implementation details and architectural considerations. Here\'s an updated, more thorough version:\n\n<doc>\n# Comprehensive Technical Specification: Social Work Survey Application\n\n## Table of Contents\n\n1. Introduction\n2. System Architecture\n3. Frontend Design\n4. Backend Design\n5. Database Schema and Data Management\n6. AI-Powered Analytics Engine\n7. Authentication and Authorization\n8. Security Measures\n9. API Design\n10. Performance Optimization\n11. Testing Strategy\n12. Deployment and DevOps\n13. Monitoring and Logging\n14. User Workflows\n15. Future Enhancements\n\n## 1. Introduction\n\nThe Social Work Survey Application is a sophisticated web-based platform designed to facilitate survey creation, distribution, and analysis for social work research. It caters to three primary user roles: Administrators, Social Workers, and Participants. The system integrates advanced features such as secure messaging, AI-powered data analysis, and real-time collaboration to provide a robust tool for social work professionals and researchers.\n\n### 1.1 Project Goals\n\n1. Streamline the survey creation and distribution process for social workers\n2. Provide a secure and user-friendly interface for participants to respond to surveys\n3. Facilitate communication between social workers and participants\n4. Leverage AI for advanced data analysis and insights\n5. Ensure data privacy and security throughout the system\n6. Create a scalable and maintainable application architecture\n\n### 1.2 Key Features\n\n- User authentication with multi-factor authentication (MFA) support\n- Role-based access control (RBAC) with fine-grained permissions\n- Survey creation with advanced question types and branching logic\n- Secure messaging system with end-to-end encryption\n- Real-time collaboration for survey design and analysis\n- AI-powered data analysis with natural language querying\n- Advanced data visualization and reporting capabilities\n- Real-time notifications for new messages, survey responses, and system events\n- Responsive design for desktop and mobile devices\n- Offline mode for data collection in areas with poor internet connectivity\n\n## 2. System Architecture\n\nThe Social Work Survey Application follows a microservices architecture to ensure scalability, maintainability, and separation of concerns. The system is built using a combination of technologies optimized for performance and developer productivity.\n\n### 2.1 High-Level Architecture Diagram\n\n```\n+-------------------+        +-------------------+\n|                   |        |   API Gateway     |\n|    Frontend SPA   |<------>|   (Express.js)    |\n|    (React.js)     |        |                   |\n+-------------------+        +--------+----------+\n                                      |\n                                      |\n    +---------------+------------------+----------------+\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |  Analytics     |  | Messaging  |\n| Service |    | Service |    |    Service     |  |  Service   |\n|         |    |         |    |                |  |            |\n+---------+    +---------+    +----------------+  +------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v---------------v------------------v----------------v------+\n|                                                              |\n|                     Message Queue (RabbitMQ)                 |\n|                                                              |\n+--------------------------------------------------------------+\n    |               |                  |                |\n    |               |                  |                |\n+---v-----+    +----v----+    +--------v-------+  +-----v------+\n|         |    |         |    |                |  |            |\n|  User   |    | Survey  |    |   Analytics    |  | Messaging  |\n|   DB    |    |   DB    |    |      DB        |  |    DB      |\n|(Postgres)    |(Postgres)    |  (ClickHouse)  |  | (MongoDB)  |\n+---------+    +---------+    +----------------+  +------------+\n```\n\n### 2.2 Component Description\n\n1. Frontend SPA: A React.js based single-page application using Next.js for server-side rendering and optimal performance.\n2. API Gateway: An Express.js server that handles routing, authentication, and load balancing for microservices.\n3. User Service: Manages user accounts, authentication, and authorization.\n4. Survey Service: Handles survey creation, editing, and response collection.\n5. Analytics Service: Provides AI-powered data analysis and visualization capabilities.\n6. Messaging Service: Manages real-time communication between users.\n7. Message Queue: RabbitMQ for asynchronous communication between microservices.\n8. Databases: \n   - PostgreSQL for structured data (users and surveys)\n   - ClickHouse for high-performance analytics storage\n   - MongoDB for flexible document storage (messages and attachments)\n\n## 3. Frontend Design\n\nThe frontend of the Social Work Survey Application is built using React.js with Next.js for server-side rendering and optimal performance. It follows a component-based architecture and utilizes modern frontend practices for state management and routing.\n\n### 3.1 Technology Stack\n\n- React.js (v18+) with functional components and hooks\n- Next.js for server-side rendering and routing\n- TypeScript for type safety and improved developer experience\n- Redux Toolkit for state management\n- Styled-components for CSS-in-JS styling\n- React Query for efficient data fetching and caching\n- Framer Motion for smooth animations and transitions\n\n### 3.2 Key Components\n\n#### 3.2.1 SurveyBuilder\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useDispatch } from \'react-redux\';\nimport { createSurvey } from \'../slices/surveySlice\';\nimport { QuestionTypes, QuestionEditor, LogicBuilder, PreviewSurvey } from \'../components\';\nimport { Survey, Question } from \'../types\';\n\nconst SurveyBuilder: React.FC = () => {\n  const dispatch = useDispatch();\n  const [survey, setSurvey] = useState<Survey>({\n    title: \'\',\n    description: \'\',\n    questions: [],\n    logic: []\n  });\n\n  const addQuestion = (questionType: string) => {\n    const newQuestion: Question = {\n      id: Date.now().toString(),\n      type: questionType,\n      text: \'\',\n      options: [],\n      required: false\n    };\n    setSurvey(prev => ({ ...prev, questions: [...prev.questions, newQuestion] }));\n  };\n\n  const updateQuestion = (index: number, updatedQuestion: Question) => {\n    setSurvey(prev => ({\n      ...prev,\n      questions: prev.questions.map((q, i) => i === index ? updatedQuestion : q)\n    }));\n  };\n\n  const handleSave = () => {\n    dispatch(createSurvey(survey));\n  };\n\n  return (\n    <div className="survey-builder">\n      <h2>Create New Survey</h2>\n      <input\n        type="text"\n        value={survey.title}\n        onChange={(e) => setSurvey(prev => ({ ...prev, title: e.target.value }))}\n        placeholder="Survey Title"\n      />\n      <textarea\n        value={survey.description}\n        onChange={(e) => setSurvey(prev => ({ ...prev, description: e.target.value }))}\n        placeholder="Survey Description"\n      />\n      <QuestionTypes onAddQuestion={addQuestion} />\n      {survey.questions.map((question, index) => (\n        <QuestionEditor\n          key={question.id}\n          question={question}\n          onUpdate={(updatedQuestion) => updateQuestion(index, updatedQuestion)}\n        />\n      ))}\n      <LogicBuilder\n        questions={survey.questions}\n        logic={survey.logic}\n        onUpdateLogic={(newLogic) => setSurvey(prev => ({ ...prev, logic: newLogic }))}\n      />\n      <PreviewSurvey survey={survey} />\n      <button onClick={handleSave}>Save Survey</button>\n    </div>\n  );\n};\n\nexport default SurveyBuilder;\n```\n\n#### 3.2.2 AnalysisDashboard\n\n```typescript\nimport React, { useState } from \'react\';\nimport { useQuery, useMutation } from \'react-query\';\nimport { useSelector } from \'react-redux\';\nimport { RootState } from \'../store\';\nimport { AnalysisChart, AIQueryInput } from \'../components\';\nimport { analyzeData, generateVisualization } from \'../api/analytics\';\nimport { AnalysisResult } from \'../types\';\n\nconst AnalysisDashboard: React.FC<{ surveyId: string }> = ({ surveyId }) => {\n  const [query, setQuery] = useState(\'\');\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const { data: analysisResults, isLoading, error } = useQuery<AnalysisResult>(\n    [\'analysis\', surveyId],\n    () => analyzeData(surveyId)\n  );\n\n  const visualizationMutation = useMutation(generateVisualization);\n\n  const handleQuerySubmit = () => {\n    visualizationMutation.mutate({ surveyId, query });\n  };\n\n  if (isLoading) return <div>Loading analysis...</div>;\n  if (error) return <div>Error loading analysis</div>;\n\n  return (\n    <div className="analysis-dashboard">\n      <h2>Survey Analysis</h2>\n      <AIQueryInput\n        value={query}\n        onChange={setQuery}\n        onSubmit={handleQuerySubmit}\n      />\n      {analysisResults && (\n        <div className="analysis-results">\n          <AnalysisChart data={analysisResults.chartData} />\n          <p>{analysisResults.summary}</p>\n        </div>\n      )}\n      {visualizationMutation.isSuccess && (\n        <img src={visualizationMutation.data.imageUrl} alt="AI-generated visualization" />\n      )}\n    </div>\n  );\n};\n\nexport default AnalysisDashboard;\n```\n\n### 3.3 State Management\n\nThe application uses Redux Toolkit for global state management and React Query for server state management.\n\n```typescript\n// store.ts\nimport { configureStore } from \'@reduxjs/toolkit\';\nimport authReducer from \'./slices/authSlice\';\nimport surveyReducer from \'./slices/surveySlice\';\nimport uiReducer from \'./slices/uiSlice\';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    surveys: surveyReducer,\n    ui: uiReducer,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Example slice: surveySlice.ts\nimport { createSlice, createAsyncThunk } from \'@reduxjs/toolkit\';\nimport { Survey } from \'../types\';\nimport { createSurvey as createSurveyAPI } from \'../api/surveys\';\n\nexport const createSurvey = createAsyncThunk(\n  \'surveys/create\',\n  async (survey: Survey) => {\n    const response = await createSurveyAPI(survey);\n    return response.data;\n  }\n);\n\nconst surveySlice = createSlice({\n  name: \'surveys\',\n  initialState: {\n    list: [],\n    currentSurvey: null,\n    status: \'idle\',\n    error: null,\n  },\n  reducers: {\n    // ... other reducers\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(createSurvey.pending, (state) => {\n        state.status = \'loading\';\n      })\n      .addCase(createSurvey.fulfilled, (state, action) => {\n        state.status = \'succeeded\';\n        state.list.push(action.payload);\n      })\n      .addCase(createSurvey.rejected, (state, action) => {\n        state.status = \'failed\';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport default surveySlice.reducer;\n```\n\n## 4. Backend Design\n\nThe backend of the Social Work Survey Application is built using a microservices architecture with Node.js and Express.js. Each microservice is responsible for a specific domain of the application.\n\n### 4.1 API Gateway\n\nThe API Gateway serves as the entry point for all client requests, handling routing, authentication, and load balancing.\n\n```typescript\nimport express from \'express\';\nimport { createProxyMiddleware } from \'http-proxy-middleware\';\nimport { authenticateToken } from \'./middleware/auth\';\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(authenticateToken);\n\n// Route proxies\napp.use(\'/api/users\', createProxyMiddleware({ target: \'http://user-service:3001\' }));\napp.use(\'/api/surveys\', createProxyMiddleware({ target: \'http://survey-service:3002\' }));\napp.use(\'/api/analysis\', createProxyMiddleware({ target: \'http://analytics-service:3003\' }));\napp.use(\'/api/messages\', createProxyMiddleware({ target: \'http://messaging-service:3004\' }));\n\n// Error handling\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send(\'Something went wrong!\');\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`API Gateway running on port ${PORT}`));\n```\n\n### 4.2 User Service\n\nThe User Service handles user management, authentication, and authorization.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport bcrypt from \'bcrypt\';\nimport jwt from \'jsonwebtoken\';\nimport { User } from \'./models/User\';\n\nconst app = express();\n\napp.post(\'/register\', [\n  body(\'email\').isEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'role\').isIn([\'admin\', \'social_worker\', \'participant\']),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { email, password, role } = req.body;\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const user = await User.create({ email, password: hashedPassword, role });\n    res.status(201).json({ userId: user.id });\n  } catch (error) {\n    res.status(500).json({ error: \'Failed to create user\' });\n  }\n});\n\napp.post(\'/login\', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ where: { email } });\n    if (user && await bcrypt.compare(password, user.password)) {\n      const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: \'1h\' });\n      res.json({ token });\n    } else {\n      res.status(401).json({ error: \'Invalid credentials\' });\n    }\n  } catch (error) {\n    res.status(500).json({ error: \'Login failed\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3001;\napp.listen(PORT, () => console.log(`User Service running on port ${PORT}`));\n```\n\n### 4.3 Survey Service\n\nThe Survey Service manages survey creation, editing, and response collection.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { Survey, Response } from \'./models\';\nimport { publishEvent } from \'./utils/messageQueue\';\n\nconst app = express();\n\napp.post(\'/surveys\', [\n  body(\'title\').notEmpty(),\n  body(\'questions\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res\n\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { title, description, questions, logic } = req.body;\n    const survey = await Survey.create({\n      title,\n      description,\n      questions,\n      logic,\n      creatorId: req.user.id\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.created\', { surveyId: survey.id, creatorId: req.user.id });\n\n    res.status(201).json({ id: survey.id, message: \'Survey created successfully\' });\n  } catch (error) {\n    console.error(\'Failed to create survey:\', error);\n    res.status(500).json({ error: \'Failed to create survey\' });\n  }\n});\n\napp.post(\'/surveys/:id/responses\', [\n  body(\'answers\').isArray({ min: 1 }),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { id } = req.params;\n    const { answers } = req.body;\n    const response = await Response.create({\n      surveyId: id,\n      participantId: req.user.id,\n      answers\n    });\n\n    // Publish event to message queue\n    await publishEvent(\'survey.response.submitted\', { \n      surveyId: id, \n      responseId: response.id, \n      participantId: req.user.id \n    });\n\n    res.status(201).json({ id: response.id, message: \'Response submitted successfully\' });\n  } catch (error) {\n    console.error(\'Failed to submit response:\', error);\n    res.status(500).json({ error: \'Failed to submit response\' });\n  }\n});\n\napp.get(\'/surveys/:id/responses\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const responses = await Response.findAll({\n      where: { surveyId: id },\n      attributes: [\'id\', \'participantId\', \'answers\', \'createdAt\']\n    });\n    res.json(responses);\n  } catch (error) {\n    console.error(\'Failed to fetch responses:\', error);\n    res.status(500).json({ error: \'Failed to fetch responses\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3002;\napp.listen(PORT, () => console.log(`Survey Service running on port ${PORT}`));\n```\n\n### 4.4 Analytics Service\n\nThe Analytics Service provides data analysis capabilities, including AI-powered insights and visualization generation.\n\n```typescript\nimport express from \'express\';\nimport { body, validationResult } from \'express-validator\';\nimport { ClickHouse } from \'clickhouse\';\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\nimport { Anthropic } from \'@anthropic-ai/sdk\';\nimport { Survey, Response } from \'./models\';\n\nconst app = express();\nconst clickhouse = new ClickHouse({\n  url: process.env.CLICKHOUSE_URL,\n  port: 8123,\n  debug: false,\n  basicAuth: {\n    username: process.env.CLICKHOUSE_USER,\n    password: process.env.CLICKHOUSE_PASSWORD,\n  },\n  isUseGzip: true,\n  format: \'json\',\n  raw: false,\n  config: {\n    session_timeout: 60,\n    output_format_json_quote_64bit_integers: 0,\n    enable_http_compression: 1,\n  },\n});\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\nconst MODEL_NAME = \'claude-3-opus-20240229\';\n\nconst SYSTEM_PROMPT = `\nYou are an expert data scientist specializing in social work research. Your task is to analyze survey data and provide insights. You can use Python to perform statistical analysis and create visualizations. Always consider the ethical implications of your analysis in the context of social work.\n`;\n\napp.post(\'/analyze\', [\n  body(\'surveyId\').isUUID(),\n  body(\'query\').notEmpty(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { surveyId, query } = req.body;\n    const survey = await Survey.findByPk(surveyId, { include: Response });\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    const codeInterpreter = await CodeInterpreter.create();\n\n    const message = await anthropic.beta.tools.messages.create({\n      model: MODEL_NAME,\n      system: SYSTEM_PROMPT,\n      max_tokens: 4096,\n      messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(survey)}` }],\n      tools: [{\n        name: \'execute_python\',\n        description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n        input_schema: {\n          type: \'object\',\n          properties: {\n            code: {\n              type: \'string\',\n              description: \'The Python code to execute in a single cell.\'\n            }\n          },\n          required: [\'code\']\n        }\n      }],\n    });\n\n    let result = { text: \'\', visualization: null };\n\n    if (message.stop_reason === \'tool_use\') {\n      const toolBlock = message.content.find((block) => block.type === \'tool_use\');\n      if (toolBlock.name === \'execute_python\') {\n        const codeOutput = await codeInterpreter.notebook.execCell(toolBlock.input.code);\n        \n        result.text = codeOutput.logs.join(\'\\n\');\n\n        if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n          result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n        }\n      }\n    } else {\n      result.text = message.content[0].text;\n    }\n\n    // Store analysis result in ClickHouse for future reference\n    await clickhouse.insert(\'analysis_results\', [{\n      survey_id: surveyId,\n      query,\n      result: JSON.stringify(result),\n      created_at: new Date()\n    }]);\n\n    res.json(result);\n  } catch (error) {\n    console.error(\'Failed to analyze survey data:\', error);\n    res.status(500).json({ error: \'Failed to analyze survey data\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3003;\napp.listen(PORT, () => console.log(`Analytics Service running on port ${PORT}`));\n```\n\n### 4.5 Messaging Service\n\nThe Messaging Service handles real-time communication between users.\n\n```typescript\nimport express from \'express\';\nimport { Server } from \'socket.io\';\nimport http from \'http\';\nimport { body, validationResult } from \'express-validator\';\nimport { Message } from \'./models\';\nimport { verifyToken } from \'./utils/auth\';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (error) {\n    next(new Error(\'Authentication error\'));\n  }\n});\n\nio.on(\'connection\', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  socket.on(\'join:room\', (roomId) => {\n    socket.join(roomId);\n  });\n\n  socket.on(\'message:send\', async (message) => {\n    try {\n      const savedMessage = await Message.create({\n        senderId: socket.user.id,\n        receiverId: message.receiverId,\n        content: message.content,\n        roomId: message.roomId\n      });\n\n      io.to(message.roomId).emit(\'message:received\', savedMessage);\n    } catch (error) {\n      console.error(\'Failed to save message:\', error);\n      socket.emit(\'message:error\', { error: \'Failed to send message\' });\n    }\n  });\n\n  socket.on(\'disconnect\', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\napp.post(\'/messages\', [\n  body(\'receiverId\').isUUID(),\n  body(\'content\').notEmpty(),\n  body(\'roomId\').isUUID(),\n], async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  try {\n    const { receiverId, content, roomId } = req.body;\n    const message = await Message.create({\n      senderId: req.user.id,\n      receiverId,\n      content,\n      roomId\n    });\n\n    io.to(roomId).emit(\'message:received\', message);\n\n    res.status(201).json(message);\n  } catch (error) {\n    console.error(\'Failed to create message:\', error);\n    res.status(500).json({ error: \'Failed to create message\' });\n  }\n});\n\napp.get(\'/messages/:roomId\', async (req, res) => {\n  try {\n    const { roomId } = req.params;\n    const messages = await Message.findAll({\n      where: { roomId },\n      order: [[\'createdAt\', \'ASC\']],\n      limit: 50\n    });\n    res.json(messages);\n  } catch (error) {\n    console.error(\'Failed to fetch messages:\', error);\n    res.status(500).json({ error: \'Failed to fetch messages\' });\n  }\n});\n\nconst PORT = process.env.PORT || 3004;\nserver.listen(PORT, () => console.log(`Messaging Service running on port ${PORT}`));\n```\n\n## 5. Database Schema and Data Management\n\nThe application uses a combination of PostgreSQL for structured data and ClickHouse for high-performance analytics storage. MongoDB is used for flexible document storage, particularly for messages and attachments.\n\n### 5.1 PostgreSQL Schema\n\n```sql\n-- Users Table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role VARCHAR(20) NOT NULL CHECK (role IN (\'admin\', \'social_worker\', \'participant\')),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Surveys Table\nCREATE TABLE surveys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    title VARCHAR(255) NOT NULL,\n    description TEXT,\n    creator_id UUID NOT NULL REFERENCES users(id),\n    questions JSONB NOT NULL,\n    logic JSONB,\n    is_active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Responses Table\nCREATE TABLE responses (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    survey_id UUID NOT NULL REFERENCES surveys(id),\n    participant_id UUID NOT NULL REFERENCES users(id),\n    answers JSONB NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for better query performance\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n```\n\n### 5.2 ClickHouse Schema\n\n```sql\nCREATE TABLE survey_analytics (\n    survey_id UUID,\n    participant_id UUID,\n    question_id String,\n    answer String,\n    timestamp DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, participant_id, timestamp);\n\nCREATE TABLE analysis_results (\n    id UUID DEFAULT generateUUIDv4(),\n    survey_id UUID,\n    query String,\n    result String,\n    created_at DateTime\n) ENGINE = MergeTree()\nORDER BY (survey_id, created_at);\n```\n\n### 5.3 MongoDB Schema\n\n```javascript\n// Message Schema\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: String, required: true },\n  receiverId: { type: String, required: true },\n  content: { type: String, required: true },\n  roomId: { type: String, required: true },\n  attachments: [{\n    filename: String,\n    fileUrl: String,\n    fileType: String\n  }],\n  createdAt: { type: Date, default: Date.now },\n  updatedAt: { type: Date, default: Date.now }\n});\n\nmessageSchema.index({ roomId: 1, createdAt: -1 });\n\nconst Message = mongoose.model(\'Message\', messageSchema);\n```\n\n## 6. AI-Powered Analytics Engine\n\nThe AI-powered analytics engine uses a combination of the E2B Code Interpreter and the Anthropic Claude API to provide advanced data analysis capabilities.\n\n### 6.1 E2B Code Interpreter Setup\n\n```typescript\nimport { CodeInterpreter } from \'@e2b/code-interpreter\';\n\nasync function setupCodeInterpreter() {\n  const codeInterpreter = await CodeInterpreter.create({\n    model: \'python3\',\n    env: {\n      PYTHONPATH: \'/usr/local/lib/python3.9/site-packages\'\n    }\n  });\n\n  // Install required Python packages\n  await codeInterpreter.installPackage(\'pandas\');\n  await codeInterpreter.installPackage(\'matplotlib\');\n  await codeInterpreter.installPackage(\'seaborn\');\n  await codeInterpreter.installPackage(\'scikit-learn\');\n\n  return codeInterpreter;\n}\n```\n\n### 6.2 Anthropic Claude Integration\n\n```typescript\nimport { Anthropic } from \'@anthropic-ai/sdk\';\n\nconst anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\nasync function generateAnalysis(surveyData: any, query: string) {\n  const message = await anthropic.beta.tools.messages.create({\n    model: \'claude-3-opus-20240229\',\n    system: SYSTEM_PROMPT,\n    max_tokens: 4096,\n    messages: [{ role: \'user\', content: `Analyze the following survey data and ${query}:\\n\\n${JSON.stringify(surveyData)}` }],\n    tools: [{\n      name: \'execute_python\',\n      description: \'Execute Python code in a Jupyter notebook cell and return the result, stdout, stderr, display_data, and error.\',\n      input_schema: {\n        type: \'object\',\n        properties: {\n          code: {\n            type: \'string\',\n            description: \'The Python code to execute in a single cell.\'\n          }\n        },\n        required: [\'code\']\n      }\n    }],\n  });\n\n  return message;\n}\n```\n\n### 6.3 Analysis Execution\n\n```typescript\nasync function executeAnalysis(codeInterpreter: CodeInterpreter, pythonCode: string) {\n  const codeOutput = await codeInterpreter.notebook.execCell(pythonCode);\n  \n  let result = {\n    text: codeOutput.logs.join(\'\\n\'),\n    visualization: null\n  };\n\n  if (codeOutput.results.length > 0 && codeOutput.results[0].png) {\n    result.visualization = `data:image/png;base64,${codeOutput.results[0].png}`;\n  }\n\n  return result;\n}\n```\n\n## 7. Authentication and Authorization\n\n### 7.1 JWT-based Authentication\n\n```typescript\nimport jwt from \'jsonwebtoken\';\n\nfunction generateToken(user: User): string {\n  return jwt.sign(\n    { userId: user.id, role: user.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n}\n\nfunction verifyToken(token: string): any {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET!);\n  } catch (error) {\n    throw new Error(\'Invalid token\');\n  }\n}\n\nfunction authenticateToken(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers[\'authorization\'];\n  const token = authHeader && authHeader.split(\' \')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  try {\n    const user = verifyToken(token);\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.sendStatus(403);\n  }\n}\n```\n\n### 7.2 Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n  ADMIN = \'admin\',\n  SOCIAL_WORKER = \'social_worker\',\n  PARTICIPANT = \'participant\'\n}\n\nconst PERMISSIONS = {\n  CREATE_SURVEY: [Role.ADMIN, Role.SOCIAL_WORKER],\n  VIEW_ALL_SURVEYS: [Role.ADMIN],\n  MANAGE_USERS: [Role.ADMIN],\n  RESPOND_TO_SURVEY: [Role.PARTICIPANT],\n  VIEW_ANALYTICS: [Role.ADMIN, Role.SOCIAL_WORKER]\n};\n\nfunction checkPermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.sendStatus(401);\n    }\n    if (PERMISSIONS[permission].includes(req.user.role)) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  };\n}\n```\n\n## 8. Security Measures\n\n### 8.1 Data Encryption\n\n```typescript\nimport crypto from \'crypto\';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;\nconst IV_LENGTH = 16;\n\nfunction encrypt(text: string): string {\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return iv.toString(\'hex\') + \':\' + encrypted.toString(\'hex\');\n}\n\nfunction decrypt(text: string): string {\n  const textParts = text.split(\':\');\n  const iv = Buffer.from(textParts.shift()!, \'hex\');\n  const encryptedText = Buffer.from(textParts.join(\':\'), \'hex\');\n  const decipher = crypto.createDecipheriv(\'aes-256-cbc\', Buffer.from(ENCRYPTION_KEY), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n```\n\n### 8.2 Input Validation and Sanitization\n\n```typescript\nimport { body, validationResult } from \'express-validator\';\nimport sanitizeHtml from \'sanitize-html\';\n\nconst surveyValidationRules = [\n  body(\'title\').trim().isLength({ min: 1, max: 255 }).escape(),\n  body(\'description\').trim().isLength({ max: 1000 }).customSanitizer(value => sanitizeHtml(value)),\n  body(\'questions\').isArray({ min: 1 }),\n  body(\'questions.*.text\').trim().isLength({ min: 1, max: 1000 }).escape(),\n  body(\'questions.*.type\').isIn([\'multiple_choice\', \'text\', \'rating\', \'date\']),\n];\n\nfunction validateSurvey(req: Request, res: Response, next: NextFunction) {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  next();\n}\n```\n\n### 8.3 Rate Limiting\n\n```typescript\nimport rateLimit from \'express-rate-limit\';\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(\'/api/\', apiLimiter);\n```\n\n### 8.4 Security Headers\n\n```typescript\nimport helmet from \'helmet\';\n\napp.use(helmet());\n```\n\n## 9. API Design\n\n### 9.1 RESTful API Endpoints\n\n```typescript\n// User Service\napp.post(\'/api/users/register\', registerUser);\napp.post(\'/api/users/login\', loginUser);\napp.get(\'/api/users/profile\', authenticateToken, getUserProfile);\napp.put(\'/api/users/profile\', authenticateToken, updateUserProfile);\n\n// Survey Service\napp.post(\'/api/surveys\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), createSurvey);\napp.get(\'/api/surveys\', authenticateToken, getSurveys);\napp.get(\'/api/surveys/:id\', authenticateToken, getSurveyById);\napp.put(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), updateSurvey);\napp.delete(\'/api/surveys/:id\', authenticateToken, checkPermission(\'CREATE_SURVEY\'), deleteSurvey);\napp.post(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'RESPOND_TO_SURVEY\'), submitSurveyResponse);\napp.get(\'/api/surveys/:id/responses\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getSurveyResponses);\n\n// Analytics Service\napp.post(\'/api/analysis/query\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), queryAnalysis);\napp.get(\'/api/analysis/visualizations/:id\', authenticateToken, checkPermission(\'VIEW_ANALYTICS\'), getVisualization);\n\n// Messaging Service\napp.post(\'/api/messages\', authenticateToken, sendMessage);\napp.get(\'/api/messages/:roomId\', authenticateToken, getMessages);\n```\n\n### 9.2 WebSocket Events\n\n```typescript\n// Client-side events\nsocket.emit(\'join:room\', roomId);\nsocket.emit(\'message:send\', { receiverId, content, roomId });\n\n// Server-side events\nio.to(roomId).emit(\'message:received\', message);\nsocket.emit(\'message:error\', { error: \'Failed to send message\' });\n```\n\n## 10. Performance Optimization\n\n### 10.1 Database Indexing\n\nEnsure proper indexing on frequently queried fields in PostgreSQL and ClickHouse:\n\n```sql\n-- PostgreSQL\nCREATE INDEX idx_surveys_creator_id ON surveys(creator_id);\nCREATE INDEX idx_responses_survey_id ON responses(survey_id);\nCREATE INDEX idx_responses_participant_id ON responses(participant_id);\n\n-- ClickHouse\nALTER TABLE survey_analytics ADD INDEX idx_survey_id survey_id TYPE minmax GRANULARITY 8192;\nALTER TABLE survey_analytics ADD INDEX idx_participant_id participant_id TYPE minmax GRANULARITY 8192;\n```\n\n### 10.2 Caching\n\nImplement Redis caching for frequently accessed data:\n\n```typescript\nimport { createClient } from \'redis\';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nasync function getCachedData(key: string): Promise<string | null> {\n  return await redisClient.get(key);\n}\n\nasync function setCachedData(key: string, value: string, expirationInSeconds: number): Promise<void> {\n  await redisClient.set(key, value, {\n    EX: expirationInSeconds\n  });\n}\n\n// Example usage in an API endpoint\napp.get(\'/api/surveys/:id\', authenticateToken, async (req, res) => {\n  const surveyId = req.params.id;\n  const cacheKey = `survey:${surveyId}`;\n\n  try {\n    const cachedSurvey = await getCachedData(cacheKey);\n    if (cachedSurvey) {\n      return res.json(JSON.parse(cachedSurvey));\n    }\n\n    const survey = await Survey.findByPk(surveyId);\n    if (!survey) {\n      return res.status(404).json({ error: \'Survey not found\' });\n    }\n\n    await setCachedData(cacheKey, JSON.stringify(survey), 3600); // Cache for 1 hour\n    res.json(survey);\n  } catch (error) {\n    console.error(\'Failed to fetch survey:\', error);\n    res.status(500).json({ error: \'Failed to fetch survey\' });\n  }\n});\n```\n\n### 10.3 Query Optimization\n\nUse database-specific features for optimized queries:\n\n```typescript\n// ClickHouse example: Using pre-aggregated data for faster analytics\nconst query = `\n  SELECT\n    survey_id,\n    question_id,\n    answer,\n    count() as response_count\n  FROM survey_analytics\n  WHERE survey_id = {survey_id:UUID}\n  GROUP BY\n    survey_id,\n    question_id,\n    answer\n`;\n\nconst result = await clickhouse.query(query).toPromise();\n```\n\n## 11. Testing Strategy\n\n### 11.1 Unit Testing\n\nUse Jest for unit testing both frontend and backend components:\n\n```typescript\n// Example backend unit test\nimport { generateToken, verifyToken } from \'../utils/auth\';\n\ndescribe(\'Auth Utils\', () => {\n  const mockUser = { id: \'123\', role: \'social_worker\' };\n\n  test(\'generateToken should create a valid JWT\', () => {\n    const token = generateToken(mockUser);\n    expect(typeof token).toBe(\'string\');\n    expect(token.split(\'.\').length).toBe(3);\n  });\n\n  test(\'verifyToken should correctly decode a valid token\', () => {\n    const token = generateToken(mockUser);\n    const decodedUser = verifyToken(token);\n    expect(decodedUser.userId).toBe(mockUser.id);\n    expect(decodedUser.role).toBe(mockUser.role);\n  });\n\n  test(\'verifyToken should throw an error for an invalid token\', () => {\n    expect(() => verifyToken(\'invalid.token.here\')).toThrow(\'Invalid token\');\n  });\n});\n\n// Example frontend unit test (React component)\nimport React from \'react\';\nimport { render, fireEvent, screen } from \'@testing-library/react\';\nimport { Provider } from \'react-redux\';\nimport configureStore from \'redux-mock-store\';\nimport SurveyBuilder from \'./SurveyBuilder\';\n\nconst mockStore = configureStore([]);\n\ndescribe(\'SurveyBuilder\', () => {\n  let store;\n\n  beforeEach(() => {\n    store = mockStore({\n      surveys: {\n        currentSurvey: null,\n      },\n    });\n  });\n\n  test(\'renders survey title input\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    expect(screen.getByPlaceholderText(\'Survey Title\')).toBeInTheDocument();\n  });\n\n  test(\'adds a new question when "Add Question" button is clicked\', () => {\n    render(\n      <Provider store={store}>\n        <SurveyBuilder />\n      </Provider>\n    );\n    const addButton = screen.getByText(\'Add Question\');\n    fireEvent.click(addButton);\n    expect(screen.getByTestId(\'question-editor\')).toBeInTheDocument();\n  });\n});\n```\n\n### 11.2 Integration Testing\n\nUse Supertest for API integration tests:\n\n```typescript\nimport request from \'supertest\';\nimport app from \'../app\';\nimport { User, Survey } from \'../models\';\n\ndescribe(\'Survey API\', () => {\n  let token;\n  let testUser;\n\n  beforeAll(async () => {\n    testUser = await User.create({\n      email: \'test@example.com\',\n      password: \'password123\',\n      role: \'social_worker\',\n    });\n    const loginResponse = await request(app)\n      .post(\'/api/users/login\')\n      .send({ email: \'test@example.com\', password: \'password123\' });\n    token = loginResponse.body.token;\n  });\n\n  afterAll(async () => {\n    await User.destroy({ where: { id: testUser.id } });\n  });\n\n  test(\'POST /api/surveys creates a new survey\', async () => {\n    const surveyData = {\n      title: \'Test Survey\',\n      description: \'This is a test survey\',\n      questions: [\n        { type: \'text\', text: \'What is your name?\' },\n        { type: \'multiple_choice\', text: \'Choose your favorite color\', options: [\'Red\', \'Blue\', \'Green\'] },\n      ],\n    };\n\n    const response = await request(app)\n      .post(\'/api/surveys\')\n      .set(\'Authorization\', `Bearer ${token}`)\n      .send(surveyData);\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty(\'id\');\n    expect(response.body.title).toBe(surveyData.title);\n\n    // Clean up\n    await Survey.destroy({ where: { id: response.body.id } });\n  });\n});\n```\n\n### 11.3 End-to-End Testing\n\nUse Cypress for end-to-end testing:\n\n```typescript\ndescribe(\'Survey Creation\', () => {\n  beforeEach(() => {\n    cy.login(\'socialworker@example.com\', \'password123\');\n  });\n\n  it(\'creates a new survey\', () => {\n    cy.visit(\'/surveys/new\');\n    cy.get(\'input[name="title"]\').type(\'E2E Test Survey\');\n    cy.get(\'textarea[name="description"]\').type(\'This is an E2E test survey\');\n    cy.get(\'button\').contains(\'Add Question\').click();\n    cy.get(\'input[name="questionText"]\').type(\'What is your age?\');\n    cy.get(\'select[name="questionType"]\').select(\'number\');\n    cy.get(\'button\').contains(\'Save Survey\').click();\n    cy.url().should(\'include\', \'/surveys\');\n    cy.contains(\'E2E Test Survey\').should(\'be.visible\');\n  });\n});\n```\n\n## 12. Deployment and DevOps\n\n### 12.1 Docker Configuration\n\nCreate a Dockerfile for each microservice:\n\n```dockerfile\n# Dockerfile for Node.js services\nFROM node:18-alpine\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 3000\n\nCMD [ "node", "server.js" ]\n```\n\n### 12.2 Kubernetes Deployment\n\nCreate Kubernetes deployment and service files for each microservice:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: survey-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: survey-service\n  template:\n    metadata:\n      labels:\n        app: survey-service\n    spec:\n      containers:\n      - name: survey-service\n        image: your-registry/survey-service:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: redis-url\n\n---\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: survey-service\nspec:\n  selector:\n    app: survey-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: ClusterIP\n```\n\n### 12.3 CI/CD Pipeline\n\nSet up a CI/CD pipeline using GitHub Actions:\n\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: \'18.x\'\n    - run: npm ci\n    - run: npm run test\n\n  build-and-push:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      env:\n        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}\n        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}\n      run: |\n        docker build -t your-registry/survey-service:${{ github.sha }} .\n        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin\n        docker push your-registry/survey-service:${{ github.sha }}\n\n  deploy:\n    needs: build-and-push\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Deploy to Kubernetes\n      env:\n        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}\n      run: |\n        echo "$KUBE_CONFIG" > kubeconfig.yaml\n        kubectl --kubeconfig=kubeconfig.yaml set image deployment/survey-service survey-service=your-registry/survey-service:${{ github.sha }}\n```\n\n## 13. Monitoring and Logging\n\n### 13.1 Application Monitoring\n\nImplement Prometheus and Grafana for monitoring:\n\n```typescript\nimport express from \'express\';\nimport promClient from \'prom-client\';\n\nconst app = express();\n\n// Create a Registry to register the metrics\nconst register = new promClient.Registry();\n\n// Add a default label which is added to all metrics\nregister.setDefaultLabels({\n  app: \'survey-service\'\n});\n\n// Enable the collection of default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Define a custom metric\nconst httpRequestDurationMicroseconds = new promClient.Histogram({\n  name: \'http_request_duration_seconds\',\n  help: \'Duration of HTTP requests in seconds\',\n  labelNames: [\'method\', \'route\', \'code\'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\n// Register the custom metric\nregister.registerMetric(httpRequestDurationMicroseconds);\n\n// Middleware to measure request duration\napp.use((req, res, next) => {\n  const start = process.hrtime();\n  \n  res.on(\'finish\', () => {\n    const duration = process.hrtime(start);\n    const durationInSeconds = duration[0] + duration[1] / 1e9;\n    \n    httpRequestDurationMicroseconds\n      .labels(req.method, req.route?.path || req.path, res.statusCode.toString())\n      .observe(durationInSeconds);\n  });\n  \n  next();\n});\n\n// Expose metrics endpoint\napp.get(\'/metrics\', async (req, res) => {\n  res.set(\'Content-Type\', register.contentType);\n  res.end(await register.metrics());\n});\n```\n\n### 13.2 Logging\n\nImplement structured logging using Winston:\n\n```typescript\nimport winston from \'winston\';\n\nconst logger = winston.createLogger({\n  level: \'info\',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: \'survey-service\' },\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: \'error.log\', level: \'error\' }),\n    new winston.transports.File({ filename: \'combined.log\' })\n  ]\n});\n\n// Example usage\nlogger.info(\'Survey created\', { surveyId: \'abc123\', userId: \'user456\' });\nlogger.error(\'Failed to create survey\', { error: \'Database connection failed\' });\n```\n\n## 14. User Workflows\n\n### 14.1 Survey Creation Workflow\n\n1. Social Worker logs in to the application\n2. Navigates to the "Create Survey" page\n3. Fills in survey title and description\n4. Adds questions using the SurveyBuilder component\n   - Selects question type (e.g., multiple choice, text input, rating scale)\n   - Enters question text and options (if applicable)\n   - Sets question as required or optional\n   - Configures any conditional logic or skip patterns\n5. Previews the survey using the PreviewSurvey component\n6. Saves the survey\n7. Optionally sets distribution settings (e.g., start date, end date, participant groups)\n8. Publishes the survey, making it available for participants\n\n### 14.2 Survey Response Workflow\n\n1. Participant receives a survey invitation (email or in-app notification)\n2. Clicks on the survey link and is directed to the survey page\n3. Reads the survey introduction and starts answering questions\n4. Navigates through the survey, with questions dynamically shown or hidden based on conditional logic\n5. Can save progress and return later if the survey allows partial completion\n6. Submits the completed survey\n7. Receives a confirmation message and any follow-up instructions\n\n### 14.3 Data Analysis Workflow\n\n1. Social Worker or Administrator logs in to the application\n2. Navigates to the "Analytics" page\n3. Selects a survey to analyze\n4. Views basic metrics and summary statistics (e.g., response rate, average completion time)\n5. Uses the AI Query Interface to ask specific questions about the data, such as:\n   - "What is the correlation between age and satisfaction scores?"\n   - "Generate a pie chart of responses to question 5"\n   - "Identify any significant trends in the open-ended responses"\n6. Reviews the AI-generated analysis, including text insights and visualizations\n7. Can refine queries or ask follow-up questions based on initial results\n8. Optionally exports the analysis results or raw data for further processing\n\n## 15. Future Enhancements\n\n1. Mobile Application: Develop a progressive web app (PWA) to improve accessibility for participants on mobile devices.\n\n2. Advanced Analytics: Expand the AI capabilities to include more complex statistical analyses, predictive modeling, and sentiment analysis of open-ended responses.\n\n3. Multi-language Support: Implement internationalization (i18n) to support multiple languages in the application, including survey questions and AI-generated insights.\n\n4. Integration with External Systems: Develop APIs to integrate with other social work management systems, government databases, or academic research platforms.\n\n5. Offline Mode: Implement robust offline capabilities for the web app to allow data collection in areas with poor internet connectivity, with automatic synchronization when connection is restored.\n\n6. Customizable Dashboards: Allow users to create personalized dashboards with custom visualizations, KPIs, and frequently used queries.\n\n7. Automated Reporting: Develop a feature to generate and schedule automated reports based on survey data and analysis, with customizable templates and distribution options.\n\n8. Enhanced Data Visualization: Integrate more advanced data visualization libraries (e.g., D3.js) to provide a wider range of interactive and customizable charts and graphs.\n\n9. Collaborative Features: Implement real-time collaboration tools for social workers to work together on survey design, analysis, and report generation.\n\n10. AI-powered Survey Generation: Develop an AI assistant that can help social workers create effective surveys based on their research goals, target population, and best practices in the field.\n\n11. Blockchain for Data Integrity: Explore the use of blockchain technology to ensure the immutability and traceability of critical survey data and analysis results.\n\n12. Virtual Reality (VR) Data Exploration: Develop a VR interface for immersive exploration of complex survey data and relationships between variables.\n\nThis comprehensive technical specification provides a solid foundation for building a sophisticated, scalable, and feature-rich Social Work Survey Application. It covers all aspects of the system, from frontend and backend architecture to advanced AI integration, security measures, and future enhancements. By following this design, you can create a powerful tool that meets the needs of social workers, researchers, and participants while ensuring performance, security, and extensibility.</context>\n\nGenerate a detailed prompt for the following subspec: PostgreSQL Database Schema: Surveys and Questions\n\nRequirements: Create the database schema for surveys and questions, including support for different question types and branching logic.\n\nDependencies: System Architecture Design: [\'```typescript\\n// System Architecture Design\\n\\n// Requirements:\\n// Design a comprehensive system architecture for the Social Work Survey Application. The architecture should follow a microservices approach and include the following components:\\n// - Frontend Single Page Application (SPA)\\n// - API Gateway\\n// - User Service (for authentication and user management)\\n// - Survey Service (for creating, managing, and responding to surveys)\\n// - Analytics Service (for AI-powered data analysis and visualization)\\n\']'}], 'model': 'claude-3-sonnet-20240229', 'system': "We need to break this down into smaller concerns that we can prompt code generation LLMs with. Please think about ways to split this and then make a section for each 'modularizable' part with the prompt in the code block, followed by any follow up comments for the devs getting the code it generates. Modularize as small as reasonably possible, so this usually means one prompt per page or a service. Be verbose and thorough. You will be prompting claude-sonnet-3.5 (if that matters).", 'temperature': 0}}
2024-07-03 23:45:26,190 - DEBUG - Sending HTTP Request: POST https://api.anthropic.com/v1/messages
2024-07-03 23:45:26,192 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2024-07-03 23:45:26,207 - DEBUG - send_request_headers.complete
2024-07-03 23:45:26,209 - DEBUG - send_request_body.started request=<Request [b'POST']>
2024-07-03 23:45:26,211 - DEBUG - send_request_body.complete
2024-07-03 23:45:26,212 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2024-07-03 23:45:29,875 - DEBUG - receive_response_headers.failed exception=KeyboardInterrupt()
2024-07-03 23:45:29,878 - DEBUG - response_closed.started
2024-07-03 23:45:29,880 - DEBUG - response_closed.complete
